<!doctype html>
<html lang='en-us'>
	<head>
		<meta charset='utf-8' />
		<link href='stylesheet.css' rel='stylesheet' type='text/css' />
		<title>Skeleton ← CS & BIC</title>
	</head>
	<body>
		<header>
			<h1><a href='index.html'>CS & BIC</a> → Skeleton</h1>
		</header>
		<h2>Synopsis</h2>
		<p><dfn>Skeleton</dfn> is a method of organizing symmetric keys into a hierarchical tree without dependence upon a centralized store of keys, instead only requiring access to the names of keys that are one’s descendants as well as one’s personal key.</p>
		<h2>Specification</h2>
		<p>To generate a child’s key, the parent will hash its key with the child’s name as a salt—the keys of grandchildren may be generated by generating each child until you arrive at the desired descendant.</p>
		<h2>Distribution</h2>
		<p>Skeleton is released as a <a href='#'>package</a> written in <a href='https://golang.org'>Go</a> under the MIT License. Skeleton is currently at version 1.0.0, and will likely not undergo any changes.</p>
		<h2>Example</h2>
<pre><code>package main
import (
	"crypto/sha512"
	"fmt"
	"yourmodule/skeleton"
)
func main() {
	hasher := func(data []byte) ([]byte, error){
		digest := sha512.Sum512_256(data)
		return digest[:], nil
	}
	parent, issue := hasher([]byte("root"))
	if issue != nil {
		panic(issue)
	}
	path := [][]byte{
		[]byte("alice"),
	}
	fmt.Println("ROOT'S KEY: ", parent)
	key, issue := skeleton.Generate(hasher, parent, path)
	if issue != nil {
		panic(issue)
	}
	fmt.Println("ALICE'S KEY: ", key)
	path = append(path, []byte("bob"))
	key, issue = skeleton.Generate(hasher, parent, path)
	if issue != nil {
		panic(issue)
	}
	fmt.Println("BOB'S KEY: ", key)
}</code></pre>
	</body>
</html>
